{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildRequestError = exports.APIResponseError = exports.UnknownHTTPResponseError = exports.isHTTPResponseError = exports.RequestTimeoutError = exports.isNotionClientError = exports.ClientErrorCode = exports.APIErrorCode = void 0;\n\nconst helpers_1 = require(\"./helpers\");\n/**\n * Error codes returned in responses from the API.\n */\n\n\nvar APIErrorCode;\n\n(function (APIErrorCode) {\n  APIErrorCode[\"Unauthorized\"] = \"unauthorized\";\n  APIErrorCode[\"RestrictedResource\"] = \"restricted_resource\";\n  APIErrorCode[\"ObjectNotFound\"] = \"object_not_found\";\n  APIErrorCode[\"RateLimited\"] = \"rate_limited\";\n  APIErrorCode[\"InvalidJSON\"] = \"invalid_json\";\n  APIErrorCode[\"InvalidRequestURL\"] = \"invalid_request_url\";\n  APIErrorCode[\"InvalidRequest\"] = \"invalid_request\";\n  APIErrorCode[\"ValidationError\"] = \"validation_error\";\n  APIErrorCode[\"ConflictError\"] = \"conflict_error\";\n  APIErrorCode[\"InternalServerError\"] = \"internal_server_error\";\n  APIErrorCode[\"ServiceUnavailable\"] = \"service_unavailable\";\n})(APIErrorCode = exports.APIErrorCode || (exports.APIErrorCode = {}));\n/**\n * Error codes generated for client errors.\n */\n\n\nvar ClientErrorCode;\n\n(function (ClientErrorCode) {\n  ClientErrorCode[\"RequestTimeout\"] = \"notionhq_client_request_timeout\";\n  ClientErrorCode[\"ResponseError\"] = \"notionhq_client_response_error\";\n})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));\n/**\n * Base error type.\n */\n\n\nclass NotionClientErrorBase extends Error {}\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\n\n\nfunction isNotionClientError(error) {\n  return (0, helpers_1.isObject)(error) && error instanceof NotionClientErrorBase;\n}\n\nexports.isNotionClientError = isNotionClientError;\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\n\nfunction isNotionClientErrorWithCode(error, codes) {\n  return isNotionClientError(error) && error.code in codes;\n}\n/**\n * Error thrown by the client if a request times out.\n */\n\n\nclass RequestTimeoutError extends NotionClientErrorBase {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Request to Notion API has timed out\";\n    super(message);\n    this.code = ClientErrorCode.RequestTimeout;\n    this.name = \"RequestTimeoutError\";\n  }\n\n  static isRequestTimeoutError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true\n    });\n  }\n\n  static rejectAfterTimeout(promise, timeoutMS) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError());\n      }, timeoutMS);\n      promise.then(resolve).catch(reject).then(() => clearTimeout(timeoutId));\n    });\n  }\n\n}\n\nexports.RequestTimeoutError = RequestTimeoutError;\n\nclass HTTPResponseError extends NotionClientErrorBase {\n  constructor(args) {\n    super(args.message);\n    this.name = \"HTTPResponseError\";\n    const {\n      code,\n      status,\n      headers,\n      rawBodyText\n    } = args;\n    this.code = code;\n    this.status = status;\n    this.headers = headers;\n    this.body = rawBodyText;\n  }\n\n}\n\nconst httpResponseErrorCodes = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\n\nfunction isHTTPResponseError(error) {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isHTTPResponseError = isHTTPResponseError;\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\n\nclass UnknownHTTPResponseError extends HTTPResponseError {\n  constructor(args) {\n    var _a;\n\n    super({ ...args,\n      code: ClientErrorCode.ResponseError,\n      message: (_a = args.message) !== null && _a !== void 0 ? _a : `Request to Notion API failed with status: ${args.status}`\n    });\n    this.name = \"UnknownHTTPResponseError\";\n  }\n\n  static isUnknownHTTPResponseError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true\n    });\n  }\n\n}\n\nexports.UnknownHTTPResponseError = UnknownHTTPResponseError;\nconst apiErrorCodes = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\n\nclass APIResponseError extends HTTPResponseError {\n  constructor() {\n    super(...arguments);\n    this.name = \"APIResponseError\";\n  }\n\n  static isAPIResponseError(error) {\n    return isNotionClientErrorWithCode(error, apiErrorCodes);\n  }\n\n}\n\nexports.APIResponseError = APIResponseError;\n\nfunction buildRequestError(response, bodyText) {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText);\n\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText\n    });\n  }\n\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText\n  });\n}\n\nexports.buildRequestError = buildRequestError;\n\nfunction parseAPIErrorResponseBody(body) {\n  if (typeof body !== \"string\") {\n    return;\n  }\n\n  let parsed;\n\n  try {\n    parsed = JSON.parse(body);\n  } catch (parseError) {\n    return;\n  }\n\n  if (!(0, helpers_1.isObject)(parsed) || typeof parsed[\"message\"] !== \"string\" || !isAPIErrorCode(parsed[\"code\"])) {\n    return;\n  }\n\n  return { ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"]\n  };\n}\n\nfunction isAPIErrorCode(code) {\n  return typeof code === \"string\" && code in apiErrorCodes;\n}","map":{"version":3,"mappings":";;;;;;;AACA;AAGA;;;;;AAGA,IAAYA,YAAZ;;AAAA,WAAYA,YAAZ,EAAwB;AACtBA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACD,CAZD,EAAYA,YAAY,GAAZC,gDAAY,EAAZ,CAAZ;AAcA;;;;;AAGA,IAAYC,eAAZ;;AAAA,WAAYA,eAAZ,EAA2B;AACzBA;AACAA;AACD,CAHD,EAAYA,eAAe,GAAfD,sDAAe,EAAf,CAAZ;AAUA;;;;;AAGA,MAAeE,qBAAf,SAEUC,KAFV,CAEe;AAuBf;;;;;;AAIA,SAAgBC,mBAAhB,CACEC,KADF,EACgB;AAEd,SAAO,wBAASA,KAAT,KAAmBA,KAAK,YAAYH,qBAA3C;AACD;;AAJDF;AAMA;;;;;;;AAMA,SAASM,2BAAT,CACED,KADF,EAEEE,KAFF,EAE8B;AAE5B,SAAOH,mBAAmB,CAACC,KAAD,CAAnB,IAA8BA,KAAK,CAACG,IAAN,IAAcD,KAAnD;AACD;AAED;;;;;AAGA,MAAaE,mBAAb,SAAyCP,qBAAzC,CAA8F;AAI5FQ,gBAA2D;AAAA,QAA/CC,OAA+C,uEAArC,qCAAqC;AACzD,UAAMA,OAAN;AAJO,gBAAOV,eAAe,CAACW,cAAvB;AACA,gBAAO,qBAAP;AAIR;;AAE2B,SAArBC,qBAAqB,CAACR,KAAD,EAAe;AACzC,WAAOC,2BAA2B,CAACD,KAAD,EAAQ;AACxC,OAACJ,eAAe,CAACW,cAAjB,GAAkC;AADM,KAAR,CAAlC;AAGD;;AAEwB,SAAlBE,kBAAkB,CACvBC,OADuB,EAEvBC,SAFuB,EAEN;AAEjB,WAAO,IAAIC,OAAJ,CAAe,CAACC,OAAD,EAAUC,MAAV,KAAoB;AACxC,YAAMC,SAAS,GAAGC,UAAU,CAAC,MAAK;AAChCF,cAAM,CAAC,IAAIV,mBAAJ,EAAD,CAAN;AACD,OAF2B,EAEzBO,SAFyB,CAA5B;AAIAD,aAAO,CACJO,IADH,CACQJ,OADR,EAEGK,KAFH,CAESJ,MAFT,EAGGG,IAHH,CAGQ,MAAME,YAAY,CAACJ,SAAD,CAH1B;AAID,KATM,CAAP;AAUD;;AA5B2F;;AAA9FpB;;AAiCA,MAAMyB,iBAAN,SAEUvB,qBAFV,CAEqC;AAOnCQ,cAAYgB,IAAZ,EAMC;AACC,UAAMA,IAAI,CAACf,OAAX;AAbO,gBAAe,mBAAf;AAcP,UAAM;AAAEH,UAAF;AAAQmB,YAAR;AAAgBC,aAAhB;AAAyBC;AAAzB,QAAyCH,IAA/C;AACA,SAAKlB,IAAL,GAAYA,IAAZ;AACA,SAAKmB,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKE,IAAL,GAAYD,WAAZ;AACD;;AApBkC;;AAuBrC,MAAME,sBAAsB,GAA2C;AACrE,GAAC9B,eAAe,CAAC+B,aAAjB,GAAiC,IADoC;AAErE,GAACjC,YAAY,CAACkC,YAAd,GAA6B,IAFwC;AAGrE,GAAClC,YAAY,CAACmC,kBAAd,GAAmC,IAHkC;AAIrE,GAACnC,YAAY,CAACoC,cAAd,GAA+B,IAJsC;AAKrE,GAACpC,YAAY,CAACqC,WAAd,GAA4B,IALyC;AAMrE,GAACrC,YAAY,CAACsC,WAAd,GAA4B,IANyC;AAOrE,GAACtC,YAAY,CAACuC,iBAAd,GAAkC,IAPmC;AAQrE,GAACvC,YAAY,CAACwC,cAAd,GAA+B,IARsC;AASrE,GAACxC,YAAY,CAACyC,eAAd,GAAgC,IATqC;AAUrE,GAACzC,YAAY,CAAC0C,aAAd,GAA8B,IAVuC;AAWrE,GAAC1C,YAAY,CAAC2C,mBAAd,GAAoC,IAXiC;AAYrE,GAAC3C,YAAY,CAAC4C,kBAAd,GAAmC;AAZkC,CAAvE;;AAeA,SAAgBC,mBAAhB,CACEvC,KADF,EACgB;AAEd,MAAI,CAACC,2BAA2B,CAACD,KAAD,EAAQ0B,sBAAR,CAAhC,EAAiE;AAC/D,WAAO,KAAP;AACD;;AAOD,SAAO,IAAP;AACD;;AAbD/B;AAeA;;;;;AAIA,MAAa6C,wBAAb,SAA8CpB,iBAA9C,CAA8F;AAG5Ff,cAAYgB,IAAZ,EAKC;;;AACC,UAAM,EACJ,GAAGA,IADC;AAEJlB,UAAI,EAAEP,eAAe,CAAC+B,aAFlB;AAGJrB,aAAO,EACL,UAAI,CAACA,OAAL,MAAY,IAAZ,IAAYmC,aAAZ,GAAYA,EAAZ,GACA,6CAA6CpB,IAAI,CAACC,MAAM;AALtD,KAAN;AARO,gBAAO,0BAAP;AAeR;;AAEgC,SAA1BoB,0BAA0B,CAC/B1C,KAD+B,EACjB;AAEd,WAAOC,2BAA2B,CAACD,KAAD,EAAQ;AACxC,OAACJ,eAAe,CAAC+B,aAAjB,GAAiC;AADO,KAAR,CAAlC;AAGD;;AAxB2F;;AAA9FhC;AA2BA,MAAMgD,aAAa,GAAkC;AACnD,GAACjD,YAAY,CAACkC,YAAd,GAA6B,IADsB;AAEnD,GAAClC,YAAY,CAACmC,kBAAd,GAAmC,IAFgB;AAGnD,GAACnC,YAAY,CAACoC,cAAd,GAA+B,IAHoB;AAInD,GAACpC,YAAY,CAACqC,WAAd,GAA4B,IAJuB;AAKnD,GAACrC,YAAY,CAACsC,WAAd,GAA4B,IALuB;AAMnD,GAACtC,YAAY,CAACuC,iBAAd,GAAkC,IANiB;AAOnD,GAACvC,YAAY,CAACwC,cAAd,GAA+B,IAPoB;AAQnD,GAACxC,YAAY,CAACyC,eAAd,GAAgC,IARmB;AASnD,GAACzC,YAAY,CAAC0C,aAAd,GAA8B,IATqB;AAUnD,GAAC1C,YAAY,CAAC2C,mBAAd,GAAoC,IAVe;AAWnD,GAAC3C,YAAY,CAAC4C,kBAAd,GAAmC;AAXgB,CAArD;AAcA;;;;;AAIA,MAAaM,gBAAb,SAAsCxB,iBAAtC,CAAqE;AAArEf;;AACW,gBAAO,kBAAP;AAKV;;AAH0B,SAAlBwC,kBAAkB,CAAC7C,KAAD,EAAe;AACtC,WAAOC,2BAA2B,CAACD,KAAD,EAAQ2C,aAAR,CAAlC;AACD;;AALkE;;AAArEhD;;AAQA,SAAgBmD,iBAAhB,CACEC,QADF,EAEEC,QAFF,EAEkB;AAEhB,QAAMC,oBAAoB,GAAGC,yBAAyB,CAACF,QAAD,CAAtD;;AACA,MAAIC,oBAAoB,KAAKE,SAA7B,EAAwC;AACtC,WAAO,IAAIP,gBAAJ,CAAqB;AAC1BzC,UAAI,EAAE8C,oBAAoB,CAAC9C,IADD;AAE1BG,aAAO,EAAE2C,oBAAoB,CAAC3C,OAFJ;AAG1BiB,aAAO,EAAEwB,QAAQ,CAACxB,OAHQ;AAI1BD,YAAM,EAAEyB,QAAQ,CAACzB,MAJS;AAK1BE,iBAAW,EAAEwB;AALa,KAArB,CAAP;AAOD;;AACD,SAAO,IAAIR,wBAAJ,CAA6B;AAClClC,WAAO,EAAE6C,SADyB;AAElC5B,WAAO,EAAEwB,QAAQ,CAACxB,OAFgB;AAGlCD,UAAM,EAAEyB,QAAQ,CAACzB,MAHiB;AAIlCE,eAAW,EAAEwB;AAJqB,GAA7B,CAAP;AAMD;;AApBDrD;;AAsBA,SAASuD,yBAAT,CACEzB,IADF,EACc;AAEZ,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B;AACD;;AAED,MAAI2B,MAAJ;;AACA,MAAI;AACFA,UAAM,GAAGC,IAAI,CAACC,KAAL,CAAW7B,IAAX,CAAT;AACD,GAFD,CAEE,OAAO8B,UAAP,EAAmB;AACnB;AACD;;AAED,MACE,CAAC,wBAASH,MAAT,CAAD,IACA,OAAOA,MAAM,CAAC,SAAD,CAAb,KAA6B,QAD7B,IAEA,CAACI,cAAc,CAACJ,MAAM,CAAC,MAAD,CAAP,CAHjB,EAIE;AACA;AACD;;AAED,SAAO,EACL,GAAGA,MADE;AAELjD,QAAI,EAAEiD,MAAM,CAAC,MAAD,CAFP;AAGL9C,WAAO,EAAE8C,MAAM,CAAC,SAAD;AAHV,GAAP;AAKD;;AAED,SAASI,cAAT,CAAwBrD,IAAxB,EAAqC;AACnC,SAAO,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,IAAIwC,aAA3C;AACD","names":["APIErrorCode","exports","ClientErrorCode","NotionClientErrorBase","Error","isNotionClientError","error","isNotionClientErrorWithCode","codes","code","RequestTimeoutError","constructor","message","RequestTimeout","isRequestTimeoutError","rejectAfterTimeout","promise","timeoutMS","Promise","resolve","reject","timeoutId","setTimeout","then","catch","clearTimeout","HTTPResponseError","args","status","headers","rawBodyText","body","httpResponseErrorCodes","ResponseError","Unauthorized","RestrictedResource","ObjectNotFound","RateLimited","InvalidJSON","InvalidRequestURL","InvalidRequest","ValidationError","ConflictError","InternalServerError","ServiceUnavailable","isHTTPResponseError","UnknownHTTPResponseError","_a","isUnknownHTTPResponseError","apiErrorCodes","APIResponseError","isAPIResponseError","buildRequestError","response","bodyText","apiErrorResponseBody","parseAPIErrorResponseBody","undefined","parsed","JSON","parse","parseError","isAPIErrorCode"],"sources":["C:\\Programming\\github\\Proj3\\aggie-fangs\\node_modules\\@notionhq\\client\\src\\errors.ts"],"sourcesContent":["import { SupportedResponse } from \"./fetch-types\"\nimport { isObject } from \"./helpers\"\nimport { Assert } from \"./type-utils\"\n\n/**\n * Error codes returned in responses from the API.\n */\nexport enum APIErrorCode {\n  Unauthorized = \"unauthorized\",\n  RestrictedResource = \"restricted_resource\",\n  ObjectNotFound = \"object_not_found\",\n  RateLimited = \"rate_limited\",\n  InvalidJSON = \"invalid_json\",\n  InvalidRequestURL = \"invalid_request_url\",\n  InvalidRequest = \"invalid_request\",\n  ValidationError = \"validation_error\",\n  ConflictError = \"conflict_error\",\n  InternalServerError = \"internal_server_error\",\n  ServiceUnavailable = \"service_unavailable\",\n}\n\n/**\n * Error codes generated for client errors.\n */\nexport enum ClientErrorCode {\n  RequestTimeout = \"notionhq_client_request_timeout\",\n  ResponseError = \"notionhq_client_response_error\",\n}\n\n/**\n * Error codes on errors thrown by the `Client`.\n */\nexport type NotionErrorCode = APIErrorCode | ClientErrorCode\n\n/**\n * Base error type.\n */\nabstract class NotionClientErrorBase<\n  Code extends NotionErrorCode\n> extends Error {\n  abstract code: Code\n}\n\n/**\n * Error type that encompasses all the kinds of errors that the Notion client will throw.\n */\nexport type NotionClientError =\n  | RequestTimeoutError\n  | UnknownHTTPResponseError\n  | APIResponseError\n\n// Assert that NotionClientError's `code` property is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertCodeIsNarrow = Assert<NotionErrorCode, NotionClientError[\"code\"]>\n\n// Assert that the type of `name` in NotionErrorCode is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertNameIsNarrow = Assert<\n  \"RequestTimeoutError\" | \"UnknownHTTPResponseError\" | \"APIResponseError\",\n  NotionClientError[\"name\"]\n>\n\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\nexport function isNotionClientError(\n  error: unknown\n): error is NotionClientError {\n  return isObject(error) && error instanceof NotionClientErrorBase\n}\n\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\nfunction isNotionClientErrorWithCode<Code extends NotionErrorCode>(\n  error: unknown,\n  codes: { [C in Code]: true }\n): error is NotionClientError & { code: Code } {\n  return isNotionClientError(error) && error.code in codes\n}\n\n/**\n * Error thrown by the client if a request times out.\n */\nexport class RequestTimeoutError extends NotionClientErrorBase<ClientErrorCode.RequestTimeout> {\n  readonly code = ClientErrorCode.RequestTimeout\n  readonly name = \"RequestTimeoutError\"\n\n  constructor(message = \"Request to Notion API has timed out\") {\n    super(message)\n  }\n\n  static isRequestTimeoutError(error: unknown): error is RequestTimeoutError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true,\n    })\n  }\n\n  static rejectAfterTimeout<T>(\n    promise: Promise<T>,\n    timeoutMS: number\n  ): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError())\n      }, timeoutMS)\n\n      promise\n        .then(resolve)\n        .catch(reject)\n        .then(() => clearTimeout(timeoutId))\n    })\n  }\n}\n\ntype HTTPResponseErrorCode = ClientErrorCode.ResponseError | APIErrorCode\n\nclass HTTPResponseError<\n  Code extends HTTPResponseErrorCode\n> extends NotionClientErrorBase<Code> {\n  readonly name: string = \"HTTPResponseError\"\n  readonly code: Code\n  readonly status: number\n  readonly headers: SupportedResponse[\"headers\"]\n  readonly body: string\n\n  constructor(args: {\n    code: Code\n    status: number\n    message: string\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super(args.message)\n    const { code, status, headers, rawBodyText } = args\n    this.code = code\n    this.status = status\n    this.headers = headers\n    this.body = rawBodyText\n  }\n}\n\nconst httpResponseErrorCodes: { [C in HTTPResponseErrorCode]: true } = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\nexport function isHTTPResponseError(\n  error: unknown\n): error is UnknownHTTPResponseError | APIResponseError {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false\n  }\n\n  type _assert = Assert<\n    UnknownHTTPResponseError | APIResponseError,\n    typeof error\n  >\n\n  return true\n}\n\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\nexport class UnknownHTTPResponseError extends HTTPResponseError<ClientErrorCode.ResponseError> {\n  readonly name = \"UnknownHTTPResponseError\"\n\n  constructor(args: {\n    status: number\n    message: string | undefined\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super({\n      ...args,\n      code: ClientErrorCode.ResponseError,\n      message:\n        args.message ??\n        `Request to Notion API failed with status: ${args.status}`,\n    })\n  }\n\n  static isUnknownHTTPResponseError(\n    error: unknown\n  ): error is UnknownHTTPResponseError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true,\n    })\n  }\n}\n\nconst apiErrorCodes: { [C in APIErrorCode]: true } = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\nexport class APIResponseError extends HTTPResponseError<APIErrorCode> {\n  readonly name = \"APIResponseError\"\n\n  static isAPIResponseError(error: unknown): error is APIResponseError {\n    return isNotionClientErrorWithCode(error, apiErrorCodes)\n  }\n}\n\nexport function buildRequestError(\n  response: SupportedResponse,\n  bodyText: string\n): APIResponseError | UnknownHTTPResponseError {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText)\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText,\n    })\n  }\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText,\n  })\n}\n\nfunction parseAPIErrorResponseBody(\n  body: string\n): { code: APIErrorCode; message: string } | undefined {\n  if (typeof body !== \"string\") {\n    return\n  }\n\n  let parsed: unknown\n  try {\n    parsed = JSON.parse(body)\n  } catch (parseError) {\n    return\n  }\n\n  if (\n    !isObject(parsed) ||\n    typeof parsed[\"message\"] !== \"string\" ||\n    !isAPIErrorCode(parsed[\"code\"])\n  ) {\n    return\n  }\n\n  return {\n    ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"],\n  }\n}\n\nfunction isAPIErrorCode(code: unknown): code is APIErrorCode {\n  return typeof code === \"string\" && code in apiErrorCodes\n}\n"]},"metadata":{},"sourceType":"script"}